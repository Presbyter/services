// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: im.proto

package protobuf

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type CreateAccountReq struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon   string `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	Token  string `protobuf:"bytes,4,opt,name=token,proto3" json:"token,omitempty"`
	Gender uint32 `protobuf:"varint,5,opt,name=gender,proto3" json:"gender,omitempty"`
}

func (m *CreateAccountReq) Reset()         { *m = CreateAccountReq{} }
func (m *CreateAccountReq) String() string { return proto.CompactTextString(m) }
func (*CreateAccountReq) ProtoMessage()    {}
func (*CreateAccountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{0}
}
func (m *CreateAccountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAccountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAccountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAccountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAccountReq.Merge(m, src)
}
func (m *CreateAccountReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateAccountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAccountReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAccountReq proto.InternalMessageInfo

func (m *CreateAccountReq) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CreateAccountReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateAccountReq) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *CreateAccountReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CreateAccountReq) GetGender() uint32 {
	if m != nil {
		return m.Gender
	}
	return 0
}

type CreateAccountResp struct {
	Accid string `protobuf:"bytes,1,opt,name=accid,proto3" json:"accid,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CreateAccountResp) Reset()         { *m = CreateAccountResp{} }
func (m *CreateAccountResp) String() string { return proto.CompactTextString(m) }
func (*CreateAccountResp) ProtoMessage()    {}
func (*CreateAccountResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{1}
}
func (m *CreateAccountResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAccountResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAccountResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAccountResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAccountResp.Merge(m, src)
}
func (m *CreateAccountResp) XXX_Size() int {
	return m.Size()
}
func (m *CreateAccountResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAccountResp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAccountResp proto.InternalMessageInfo

func (m *CreateAccountResp) GetAccid() string {
	if m != nil {
		return m.Accid
	}
	return ""
}

func (m *CreateAccountResp) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CreateAccountResp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type AddGroupReq struct {
	Tname    string `protobuf:"bytes,1,opt,name=tname,proto3" json:"tname,omitempty"`
	Owner    string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Members  string `protobuf:"bytes,3,opt,name=members,proto3" json:"members,omitempty"`
	Msg      string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
	Magree   int32  `protobuf:"varint,5,opt,name=magree,proto3" json:"magree,omitempty"`
	Joinmode int32  `protobuf:"varint,6,opt,name=joinmode,proto3" json:"joinmode,omitempty"`
}

func (m *AddGroupReq) Reset()         { *m = AddGroupReq{} }
func (m *AddGroupReq) String() string { return proto.CompactTextString(m) }
func (*AddGroupReq) ProtoMessage()    {}
func (*AddGroupReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{2}
}
func (m *AddGroupReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddGroupReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddGroupReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddGroupReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddGroupReq.Merge(m, src)
}
func (m *AddGroupReq) XXX_Size() int {
	return m.Size()
}
func (m *AddGroupReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddGroupReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddGroupReq proto.InternalMessageInfo

func (m *AddGroupReq) GetTname() string {
	if m != nil {
		return m.Tname
	}
	return ""
}

func (m *AddGroupReq) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *AddGroupReq) GetMembers() string {
	if m != nil {
		return m.Members
	}
	return ""
}

func (m *AddGroupReq) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *AddGroupReq) GetMagree() int32 {
	if m != nil {
		return m.Magree
	}
	return 0
}

func (m *AddGroupReq) GetJoinmode() int32 {
	if m != nil {
		return m.Joinmode
	}
	return 0
}

type AddGroupResp struct {
	Tid string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
}

func (m *AddGroupResp) Reset()         { *m = AddGroupResp{} }
func (m *AddGroupResp) String() string { return proto.CompactTextString(m) }
func (*AddGroupResp) ProtoMessage()    {}
func (*AddGroupResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{3}
}
func (m *AddGroupResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddGroupResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddGroupResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddGroupResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddGroupResp.Merge(m, src)
}
func (m *AddGroupResp) XXX_Size() int {
	return m.Size()
}
func (m *AddGroupResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddGroupResp.DiscardUnknown(m)
}

var xxx_messageInfo_AddGroupResp proto.InternalMessageInfo

func (m *AddGroupResp) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

type DeleteGroupReq struct {
	Tid   string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *DeleteGroupReq) Reset()         { *m = DeleteGroupReq{} }
func (m *DeleteGroupReq) String() string { return proto.CompactTextString(m) }
func (*DeleteGroupReq) ProtoMessage()    {}
func (*DeleteGroupReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{4}
}
func (m *DeleteGroupReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteGroupReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteGroupReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteGroupReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteGroupReq.Merge(m, src)
}
func (m *DeleteGroupReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteGroupReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteGroupReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteGroupReq proto.InternalMessageInfo

func (m *DeleteGroupReq) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *DeleteGroupReq) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

type AddFriendReq struct {
	Accid  string `protobuf:"bytes,1,opt,name=accid,proto3" json:"accid,omitempty"`
	Faccid string `protobuf:"bytes,2,opt,name=faccid,proto3" json:"faccid,omitempty"`
	Type   int32  `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Msg    string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *AddFriendReq) Reset()         { *m = AddFriendReq{} }
func (m *AddFriendReq) String() string { return proto.CompactTextString(m) }
func (*AddFriendReq) ProtoMessage()    {}
func (*AddFriendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{5}
}
func (m *AddFriendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFriendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFriendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFriendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFriendReq.Merge(m, src)
}
func (m *AddFriendReq) XXX_Size() int {
	return m.Size()
}
func (m *AddFriendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFriendReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddFriendReq proto.InternalMessageInfo

func (m *AddFriendReq) GetAccid() string {
	if m != nil {
		return m.Accid
	}
	return ""
}

func (m *AddFriendReq) GetFaccid() string {
	if m != nil {
		return m.Faccid
	}
	return ""
}

func (m *AddFriendReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *AddFriendReq) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type DeleteFriendReq struct {
	Accid  string `protobuf:"bytes,1,opt,name=accid,proto3" json:"accid,omitempty"`
	Faccid string `protobuf:"bytes,2,opt,name=faccid,proto3" json:"faccid,omitempty"`
}

func (m *DeleteFriendReq) Reset()         { *m = DeleteFriendReq{} }
func (m *DeleteFriendReq) String() string { return proto.CompactTextString(m) }
func (*DeleteFriendReq) ProtoMessage()    {}
func (*DeleteFriendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_36f2114a3e4ddb9e, []int{6}
}
func (m *DeleteFriendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFriendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFriendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFriendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFriendReq.Merge(m, src)
}
func (m *DeleteFriendReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFriendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFriendReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFriendReq proto.InternalMessageInfo

func (m *DeleteFriendReq) GetAccid() string {
	if m != nil {
		return m.Accid
	}
	return ""
}

func (m *DeleteFriendReq) GetFaccid() string {
	if m != nil {
		return m.Faccid
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateAccountReq)(nil), "CreateAccountReq")
	proto.RegisterType((*CreateAccountResp)(nil), "CreateAccountResp")
	proto.RegisterType((*AddGroupReq)(nil), "AddGroupReq")
	proto.RegisterType((*AddGroupResp)(nil), "AddGroupResp")
	proto.RegisterType((*DeleteGroupReq)(nil), "DeleteGroupReq")
	proto.RegisterType((*AddFriendReq)(nil), "AddFriendReq")
	proto.RegisterType((*DeleteFriendReq)(nil), "DeleteFriendReq")
}

func init() { proto.RegisterFile("im.proto", fileDescriptor_36f2114a3e4ddb9e) }

var fileDescriptor_36f2114a3e4ddb9e = []byte{
	// 466 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x53, 0x3d, 0x6f, 0xdb, 0x30,
	0x10, 0x35, 0xfd, 0xa1, 0xd8, 0x17, 0xbb, 0x71, 0x88, 0xc2, 0x15, 0x54, 0x40, 0x30, 0xb4, 0xd4,
	0x13, 0x03, 0xa4, 0x40, 0x90, 0xad, 0x48, 0x3f, 0x91, 0x55, 0xdd, 0xba, 0x14, 0xb6, 0x74, 0x11,
	0xd4, 0x86, 0xa2, 0x4a, 0xc9, 0x28, 0x32, 0x76, 0xee, 0xd2, 0xb5, 0xff, 0xa8, 0x63, 0xc6, 0x8e,
	0x85, 0xfd, 0x47, 0x0a, 0x7e, 0x48, 0x96, 0xed, 0x78, 0xc9, 0x76, 0xef, 0xc4, 0x7b, 0x7a, 0xef,
	0x91, 0x07, 0xfd, 0x94, 0xb3, 0x5c, 0x8a, 0x52, 0x78, 0xcf, 0x13, 0x21, 0x92, 0x5b, 0x3c, 0xd3,
	0x68, 0xb1, 0xbc, 0x39, 0x43, 0x9e, 0x97, 0x77, 0xe6, 0x63, 0xf0, 0x83, 0xc0, 0xf8, 0x8d, 0xc4,
	0x79, 0x89, 0x57, 0x51, 0x24, 0x96, 0x59, 0x19, 0xe2, 0x37, 0xfa, 0x0c, 0x8e, 0x96, 0x05, 0xca,
	0xcf, 0x69, 0xec, 0x92, 0x29, 0x99, 0x75, 0x43, 0x47, 0xc1, 0xeb, 0x98, 0x52, 0xe8, 0x66, 0x73,
	0x8e, 0x6e, 0x7b, 0x4a, 0x66, 0x83, 0x50, 0xd7, 0xaa, 0x97, 0x46, 0x22, 0x73, 0x3b, 0xa6, 0xa7,
	0x6a, 0xfa, 0x14, 0x7a, 0xa5, 0xf8, 0x8a, 0x99, 0xdb, 0xd5, 0x4d, 0x03, 0xe8, 0x04, 0x9c, 0x04,
	0xb3, 0x18, 0xa5, 0xdb, 0x9b, 0x92, 0xd9, 0x28, 0xb4, 0x28, 0xf8, 0x08, 0xa7, 0x3b, 0x12, 0x8a,
	0x5c, 0x51, 0xcc, 0xa3, 0xc8, 0x2a, 0x18, 0x84, 0x06, 0x6c, 0x88, 0xdb, 0x4d, 0xe2, 0x4a, 0x56,
	0x67, 0x23, 0x2b, 0xf8, 0x4d, 0xe0, 0xf8, 0x2a, 0x8e, 0x3f, 0x48, 0xb1, 0xcc, 0x95, 0x27, 0x35,
	0xa9, 0x0f, 0x59, 0x3e, 0x0d, 0x54, 0x57, 0x7c, 0xcf, 0x50, 0x56, 0x7c, 0x1a, 0x50, 0x17, 0x8e,
	0x38, 0xf2, 0x05, 0xca, 0xc2, 0x52, 0x56, 0x90, 0x8e, 0xa1, 0xc3, 0x8b, 0xc4, 0xda, 0x52, 0xa5,
	0x32, 0xc5, 0xe7, 0x89, 0x44, 0xd4, 0xa6, 0x7a, 0xa1, 0x45, 0xd4, 0x83, 0xfe, 0x17, 0x91, 0x66,
	0x5c, 0xc4, 0xe8, 0x3a, 0xfa, 0x4b, 0x8d, 0x83, 0x29, 0x0c, 0x37, 0xd2, 0x8a, 0x5c, 0xb1, 0x96,
	0xb5, 0x53, 0x55, 0x06, 0x97, 0xf0, 0xe4, 0x2d, 0xde, 0x62, 0x89, 0xb5, 0xfe, 0xbd, 0x33, 0x0f,
	0x6b, 0x0f, 0x16, 0x9a, 0xfb, 0xbd, 0x4c, 0x31, 0x8b, 0xad, 0xef, 0x07, 0x72, 0x9c, 0x80, 0x73,
	0x63, 0xda, 0x66, 0xd8, 0x22, 0x95, 0x64, 0x79, 0x97, 0x9b, 0x24, 0x7b, 0xa1, 0xae, 0xf7, 0x3d,
	0x07, 0xaf, 0xe0, 0xc4, 0xa8, 0x7b, 0xe4, 0x6f, 0xce, 0x7f, 0xb6, 0xa1, 0x7d, 0xcd, 0xe9, 0x05,
	0x8c, 0xb6, 0x2e, 0x9e, 0x9e, 0xb2, 0xdd, 0xb7, 0xe8, 0x51, 0xb6, 0xff, 0x36, 0x5e, 0x40, 0xbf,
	0xca, 0x8f, 0x0e, 0x59, 0xe3, 0x96, 0xbd, 0x11, 0xdb, 0x0a, 0xf6, 0x02, 0x8e, 0x1b, 0x31, 0xd2,
	0x13, 0xb6, 0x1d, 0xaa, 0x37, 0x61, 0x66, 0x37, 0x58, 0xb5, 0x1b, 0xec, 0x9d, 0xda, 0x0d, 0x7a,
	0x0e, 0x83, 0x3a, 0x44, 0xaa, 0x39, 0x6b, 0xa7, 0x07, 0x67, 0x2e, 0x61, 0xd8, 0x0c, 0x85, 0x8e,
	0xd9, 0x4e, 0x46, 0x87, 0x26, 0x5f, 0x07, 0x7f, 0x56, 0x3e, 0xb9, 0x5f, 0xf9, 0xe4, 0xdf, 0xca,
	0x27, 0xbf, 0xd6, 0x7e, 0xeb, 0x7e, 0xed, 0xb7, 0xfe, 0xae, 0xfd, 0xd6, 0xa7, 0x7e, 0x75, 0x72,
	0xe1, 0xe8, 0xea, 0xe5, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x31, 0x72, 0xa6, 0xd7, 0x03,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ImClient is the client API for Im service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImClient interface {
	CreateAccount(ctx context.Context, in *CreateAccountReq, opts ...grpc.CallOption) (*CreateAccountResp, error)
	AddGroup(ctx context.Context, in *AddGroupReq, opts ...grpc.CallOption) (*AddGroupResp, error)
	DeleteGroup(ctx context.Context, in *DeleteGroupReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddFriend(ctx context.Context, in *AddFriendReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteFriend(ctx context.Context, in *DeleteFriendReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type imClient struct {
	cc *grpc.ClientConn
}

func NewImClient(cc *grpc.ClientConn) ImClient {
	return &imClient{cc}
}

func (c *imClient) CreateAccount(ctx context.Context, in *CreateAccountReq, opts ...grpc.CallOption) (*CreateAccountResp, error) {
	out := new(CreateAccountResp)
	err := c.cc.Invoke(ctx, "/Im/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) AddGroup(ctx context.Context, in *AddGroupReq, opts ...grpc.CallOption) (*AddGroupResp, error) {
	out := new(AddGroupResp)
	err := c.cc.Invoke(ctx, "/Im/AddGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) DeleteGroup(ctx context.Context, in *DeleteGroupReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Im/DeleteGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) AddFriend(ctx context.Context, in *AddFriendReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Im/AddFriend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) DeleteFriend(ctx context.Context, in *DeleteFriendReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Im/DeleteFriend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImServer is the server API for Im service.
type ImServer interface {
	CreateAccount(context.Context, *CreateAccountReq) (*CreateAccountResp, error)
	AddGroup(context.Context, *AddGroupReq) (*AddGroupResp, error)
	DeleteGroup(context.Context, *DeleteGroupReq) (*emptypb.Empty, error)
	AddFriend(context.Context, *AddFriendReq) (*emptypb.Empty, error)
	DeleteFriend(context.Context, *DeleteFriendReq) (*emptypb.Empty, error)
}

// UnimplementedImServer can be embedded to have forward compatible implementations.
type UnimplementedImServer struct {
}

func (*UnimplementedImServer) CreateAccount(ctx context.Context, req *CreateAccountReq) (*CreateAccountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (*UnimplementedImServer) AddGroup(ctx context.Context, req *AddGroupReq) (*AddGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroup not implemented")
}
func (*UnimplementedImServer) DeleteGroup(ctx context.Context, req *DeleteGroupReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (*UnimplementedImServer) AddFriend(ctx context.Context, req *AddFriendReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFriend not implemented")
}
func (*UnimplementedImServer) DeleteFriend(ctx context.Context, req *DeleteFriendReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFriend not implemented")
}

func RegisterImServer(s *grpc.Server, srv ImServer) {
	s.RegisterService(&_Im_serviceDesc, srv)
}

func _Im_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Im/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).CreateAccount(ctx, req.(*CreateAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_AddGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).AddGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Im/AddGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).AddGroup(ctx, req.(*AddGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Im/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).DeleteGroup(ctx, req.(*DeleteGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_AddFriend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFriendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).AddFriend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Im/AddFriend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).AddFriend(ctx, req.(*AddFriendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_DeleteFriend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFriendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).DeleteFriend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Im/DeleteFriend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).DeleteFriend(ctx, req.(*DeleteFriendReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Im_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Im",
	HandlerType: (*ImServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAccount",
			Handler:    _Im_CreateAccount_Handler,
		},
		{
			MethodName: "AddGroup",
			Handler:    _Im_AddGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _Im_DeleteGroup_Handler,
		},
		{
			MethodName: "AddFriend",
			Handler:    _Im_AddFriend_Handler,
		},
		{
			MethodName: "DeleteFriend",
			Handler:    _Im_DeleteFriend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "im.proto",
}

func (m *CreateAccountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAccountReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIm(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Gender != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintIm(dAtA, i, uint64(m.Gender))
	}
	return i, nil
}

func (m *CreateAccountResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAccountResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Accid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Accid)))
		i += copy(dAtA[i:], m.Accid)
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *AddGroupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddGroupReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Tname)))
		i += copy(dAtA[i:], m.Tname)
	}
	if len(m.Owner) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if len(m.Members) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Members)))
		i += copy(dAtA[i:], m.Members)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Magree != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintIm(dAtA, i, uint64(m.Magree))
	}
	if m.Joinmode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintIm(dAtA, i, uint64(m.Joinmode))
	}
	return i, nil
}

func (m *AddGroupResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddGroupResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Tid)))
		i += copy(dAtA[i:], m.Tid)
	}
	return i, nil
}

func (m *DeleteGroupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteGroupReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Tid)))
		i += copy(dAtA[i:], m.Tid)
	}
	if len(m.Owner) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	return i, nil
}

func (m *AddFriendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFriendReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Accid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Accid)))
		i += copy(dAtA[i:], m.Accid)
	}
	if len(m.Faccid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Faccid)))
		i += copy(dAtA[i:], m.Faccid)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIm(dAtA, i, uint64(m.Type))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *DeleteFriendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFriendReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Accid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Accid)))
		i += copy(dAtA[i:], m.Accid)
	}
	if len(m.Faccid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIm(dAtA, i, uint64(len(m.Faccid)))
		i += copy(dAtA[i:], m.Faccid)
	}
	return i, nil
}

func encodeVarintIm(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CreateAccountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovIm(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	if m.Gender != 0 {
		n += 1 + sovIm(uint64(m.Gender))
	}
	return n
}

func (m *CreateAccountResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Accid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	return n
}

func (m *AddGroupReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tname)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Members)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	if m.Magree != 0 {
		n += 1 + sovIm(uint64(m.Magree))
	}
	if m.Joinmode != 0 {
		n += 1 + sovIm(uint64(m.Joinmode))
	}
	return n
}

func (m *AddGroupResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	return n
}

func (m *DeleteGroupReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	return n
}

func (m *AddFriendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Accid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Faccid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovIm(uint64(m.Type))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	return n
}

func (m *DeleteFriendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Accid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	l = len(m.Faccid)
	if l > 0 {
		n += 1 + l + sovIm(uint64(l))
	}
	return n
}

func sovIm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIm(x uint64) (n int) {
	return sovIm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateAccountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gender |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAccountResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddGroupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magree", wireType)
			}
			m.Magree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magree |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joinmode", wireType)
			}
			m.Joinmode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Joinmode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddGroupResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddGroupResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddGroupResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteGroupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFriendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFriendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFriendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Faccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFriendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFriendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFriendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Faccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIm
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIm
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIm
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIm(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIm
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIm = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIm   = fmt.Errorf("proto: integer overflow")
)
